# APConv - 即插即用模块

## 📌 结构图分析

根据提供的Figure 3，**PConv（风车形卷积）**的核心设计如下：

```
输入特征图 → 4个方向的非对称Padding → 水平/垂直卷积 → Concat融合 → 输出
```

### 关键特性：
- **非对称填充**：4个方向 (左、右、上、下) 使用不同的padding策略
- **分离卷积**：水平方向使用(1,k)卷积，垂直方向使用(k,1)卷积
- **特征融合**：将4个方向的特征concat后通过融合卷积
- **感受野**：形成风车形的感受野，提升特征提取能力

---

## 🚀 快速使用

### 1. 安装依赖
```bash
pip install torch torchvision
```

### 2. 运行测试
```bash
python APConv.py
```

### 3. 集成到你的网络

#### 示例1：使用PConv替换标准卷积
```python
import torch
from APConv import PConv

# 替换标准卷积
# 原来: conv = nn.Conv2d(64, 128, 3, 1, 1)
# 现在: conv = PConv(c1=64, c2=128, k=3, s=1)

model = PConv(c1=64, c2=128, k=3, s=1)
x = torch.randn(1, 64, 32, 32)
y = model(x)
print(y.shape)  # torch.Size([1, 128, 32, 32])
```

#### 示例2：使用APBottleneck构建网络
```python
from APConv import APBottleneck

# 作为特征提取模块
bottleneck = APBottleneck(c1=64, c2=64, shortcut=True)
x = torch.randn(1, 64, 32, 32)
y = bottleneck(x)
print(y.shape)  # torch.Size([1, 64, 32, 32])
```

#### 示例3：使用APC2f构建深层网络
```python
from APConv import APC2f

# CSP结构，适合深层网络
apc2f = APC2f(c1=64, c2=128, n=3, shortcut=True, P=True)
x = torch.randn(1, 64, 32, 32)
y = apc2f(x)
print(y.shape)  # torch.Size([1, 128, 32, 32])
```

---

## 📦 模块说明

### 1. **PConv** - 风车形卷积
- **输入**: `(B, C1, H, W)`
- **输出**: `(B, C2, H', W')`
- **参数**:
  - `c1`: 输入通道数
  - `c2`: 输出通道数
  - `k`: 卷积核大小（用于padding）
  - `s`: 步长

### 2. **APBottleneck** - 非对称填充瓶颈
- **输入**: `(B, C1, H, W)`
- **输出**: `(B, C2, H, W)`
- **参数**:
  - `c1`: 输入通道数
  - `c2`: 输出通道数
  - `shortcut`: 是否使用残差连接
  - `g`: 分组卷积组数
  - `k`: 卷积核大小元组
  - `e`: 通道扩展系数

### 3. **APC2f** - CSP结构
- **输入**: `(B, C1, H, W)`
- **输出**: `(B, C2, H, W)`
- **参数**:
  - `c1`: 输入通道数
  - `c2`: 输出通道数
  - `n`: bottleneck重复次数
  - `shortcut`: 是否使用残差连接
  - `P`: True使用APBottleneck
  - `g`: 分组卷积组数
  - `e`: 通道扩展系数

---

## 🎯 测试输出示例

运行`python APConv.py`后，你会看到类似的输出：

```
============================================================
APConv模块测试 - 即插即用测试
============================================================

输入张量shape: torch.Size([2, 64, 32, 32])

============================================================
测试1: PConv - 风车形卷积
============================================================
PConv输出shape: torch.Size([2, 128, 32, 32])
参数量: 45,440
输出统计: mean=0.0234, std=0.5678

============================================================
测试2: APBottleneck - 非对称填充瓶颈
============================================================
APBottleneck输出shape: torch.Size([2, 64, 32, 32])
参数量: 28,160
输出统计: mean=-0.0156, std=0.4321

============================================================
测试3: APC2f - CSP结构
============================================================
APC2f输出shape: torch.Size([2, 128, 32, 32])
参数量: 134,144
输出统计: mean=0.0089, std=0.3987
```

---

## 💡 使用建议

1. **PConv**: 适合作为骨干网络的基础卷积层，提供风车形感受野
2. **APBottleneck**: 适合作为特征提取的瓶颈模块
3. **APC2f**: 适合作为深层网络的CSP结构模块

### 性能优势
- ✅ 风车形感受野提供更丰富的空间信息
- ✅ 非对称填充减少计算量
- ✅ 即插即用，可直接替换标准卷积
- ✅ 与YOLO等检测框架兼容

---

## 📝 注意事项

1. 确保PyTorch版本 >= 1.8.0
2. 输出通道数`c2`应为4的倍数（PConv要求）
3. 在实际部署时，可使用`model.eval()`关闭BN和Dropout
4. 支持CUDA加速：`model = model.cuda()`

---

## 📚 参考文献

该模块基于PConv（Pinwheel-shaped Convolution）设计，使用非对称填充实现风车形感受野。

---

## 🤝 贡献

欢迎提出问题和改进建议！

